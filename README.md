# ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) PROJECT 소개 🎉

![브로셔메인](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/cfc3c265-097b-44e4-85bf-d4250a1c1d47)

| ✨ **대표 스택** | `React` `Spring`        |
| ---------------- | :---------------------- |
| 🚩 **개발 기간** | 2023.05.23 ~ 2023.06.29 |
| ➡️ **URL**       | https://ohpick.shop/    |

<br>

<br>

## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 서비스 소개 👏<br>

![KakaoTalk_20230620_001046503_01](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/e32b365a-6b10-4459-8685-272cb59dba12)

    📢  저희 'OhPick'은 우리만의 오피스 공간이 필요하신 분들을 위해 개인이 가진 공간을 오피스 공간으로
        공유, 대여할 수 있도록 중개하는 서비스입니다.

        개인 작업실부터 큰 규모의 팀 공간까지 다양한 유형의 오피스 정보를 제공해 드립니다.
        간편한 지역 검색 및 필터링 기능으로 원하는 조건에 맞는 오피스를 손쉽게 찾을 수 있을 뿐만 아니라
        간편 예약 서비스까지 제공하여 고객이 원하는 날짜에 빠른 예약이 가능하도록 설계하였습니다.

<br>

<br>

## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 아키텍처 구성도 🏗️<br>

![아키텍처 구성도](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/13250ebe-c18e-4b8e-a9bd-30b91f8f2eab)

### FRONT-END STACK 🏗️

<div align=center> 
<img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=HTML5&logoColor=white">
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=JavaScript&logoColor=black">
<img src="https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=React&logoColor=black">
<img src="https://img.shields.io/badge/React Router-CA4245?style=for-the-badge&logo=React Router&logoColor=white"> 
<img src="https://img.shields.io/badge/React Query-FF4154?style=for-the-badge&logo=React Query&logoColor=white">
<img src="https://img.shields.io/badge/Recoil-FFFFFF?style=for-the-badge&logo=&logoColor=black"/>
<img src="https://img.shields.io/badge/Axios-5A29E4?style=for-the-badge&logo=Axios&logoColor=white">
<img src="https://img.shields.io/badge/Stomp-000000?style=for-the-badge&logo=&logoColor=white"/>
<img src="https://img.shields.io/badge/Kakao Map API-FFCD00?style=for-the-badge&logo=kakao&logoColor=black">
<img src="https://img.shields.io/badge/Kakao Develop-FFCD00?style=for-the-badge&logo=kakao&logoColor=black">
<img src="https://img.shields.io/badge/Sass-CC6699?style=for-the-badge&logo=sass&logoColor=white">
<img src="https://img.shields.io/badge/TailwindCSS-06B6D4?style=for-the-badge&logo=Tailwind-CSS&logoColor=white"/>
<img src="https://img.shields.io/badge/Netlify-00C7B7?style=for-the-badge&logo=Netlify&logoColor=white">
<img src="https://img.shields.io/badge/GitHub-181717?style=for-the-badge&logo=GitHub&logoColor=white">
</div>

### BACK-END STACK 🏗️

<div align=center> 
<img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&logoColor=white"> 
<img src="https://img.shields.io/badge/SPRING BOOT-6DB33F?style=for-the-badge&logo=SPRING BOOT&logoColor=white">
<img src="https://img.shields.io/badge/springsecurity-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white">
<img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white">
<img src="https://img.shields.io/badge/redis-DC382D?style=for-the-badge&logo=redis&logoColor=white">
<img src="https://img.shields.io/badge/amazonrds-527FFF?style=for-the-badge&logo=amazonrds&logoColor=white">
<img src="https://img.shields.io/badge/amazonec2-FF9900?style=for-the-badge&logo=amazonec2&logoColor=white">
<img src="https://img.shields.io/badge/Amazon S3-569A31?style=for-the-badge&logo=Amazon S3&logoColor=white">
<img src="https://img.shields.io/badge/amazonaws-232F3E?style=for-the-badge&logo=amazonaws&logoColor=white">
<img src="https://img.shields.io/badge/AWS CodeDeploy-212599?style=for-the-badge&logo=CodeDeploy&logoColor=white">
<img src="https://img.shields.io/badge/Kakao Develop-FFCD00?style=for-the-badge&logo=kakao&logoColor=black">
<img src="https://img.shields.io/badge/JSON Web Tokens-000000?style=for-the-badge&logo=JSON Web Tokens&logoColor=white">
<img src="https://img.shields.io/badge/WebSocket-000000?style=for-the-badge&logo=&logoColor=white"/>
<img src="https://img.shields.io/badge/Stomp-000000?style=for-the-badge&logo=&logoColor=white"/>
<img src="https://img.shields.io/badge/SMTP-000000?style=for-the-badge&logo=&logoColor=white"/>
<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
<img src="https://img.shields.io/badge/GitHub Actions-2088FF?style=for-the-badge&logo=GitHub Actions&logoColor=white">

</div>
<br>

<br>

## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 주요 기능 ⚡<br>

![KakaoTalk_20230620_001046503_02](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/6e9fc9a7-d0b4-477b-8977-451c6204e4aa)

<details>
  <summary> ⚡ 게시글 CRUD 기능 (포스트 작성, 조회, 수정, 삭제) </summary>
<br>
    
<div align=center> 
    
| **오피스 조회 / 무한스크롤** | **포스트 작성** | **포스트 수정,삭제** |
| :-: | :-: | :-: |
| <img src="https://github.com/OHPick/FE/assets/83201893/cd092bd1-b872-491e-af18-9d55d2d58bf0" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/2042f2c2-9995-4450-9ba4-67bb2fde5424" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/46762781-3e8b-43ed-bc0e-369ec44df2b6" width="220" /> |

</div>

</details>
</details>
<details>
  <summary> ⚡ 예약 및 채팅 기능 </summary>
<br>

<div align=center> 
    
| **예약 하기** | **예약 확인 채팅 메세지** | **채팅 기능, 목록** |
| :-: | :-: | :-: |
| <img src="https://github.com/OHPick/FE/assets/83201893/18aa4ea5-2a6d-404e-a48f-1b60ae55cdcc" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/984e6b05-8c84-4bfc-a070-c3a66e09334d" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/773ac8aa-0818-405b-a9c5-3ad09f74ffa7" width="220" /> |

</div>

</details>
<details>
  <summary> ⚡ 키워드 / 지역 별 검색 및 로그인, 회원가입 기능 </summary>
<br>

<div align=center> 
    
| **검색 기능(키워드/필터)** | **소셜 로그인** | **회원가입** |
| :-: | :-: | :-: |
| <img src="https://github.com/OHPick/FE/assets/83201893/9c12ae6d-23ed-4494-9488-04f57966062c" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/4743708e-10c3-4b6f-9668-01281eda0adc" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/7f674741-474e-46b2-9c2c-4c3c77b68604" width="220" /> |

</div>
</details>
<details>
  <summary> ⚡ 마이페이지 (글 목록 조회, 로그아웃 및 회원 탈퇴) 기능 </summary>
<br>
<div align=center> 
    
| **마이 페이지(나의 오피스, 좋아요)** | **예약 현황** | **프로필 편집** |
| :-: | :-: | :-: |
| <img src="https://github.com/OHPick/FE/assets/83201893/69f0704c-cd9a-477b-a466-bdde7ee9911f" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/3f5811bb-6d5c-4130-9307-bff8a88d0987" width="220" /> | <img src="https://github.com/OHPick/FE/assets/83201893/1df13391-aecb-4465-b170-5d49e43a1f96" width="220" /> |

</div>
</details>

<br>

<br>

## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 기술적 의사 결정 🌻<br>

### 👥 FRONT-END

<details>
  <summary> <b>Reac-Query</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | react-query를 사용해 서버 상태를 관리하여 캐싱 처리로 속도와 성능을 개선 하기 위해 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 저희 OHPick서비스는 사용자들에게 많은 오피스 데이터들을 쾌적하게 제공해야 합니다. 특히 주요 기능인 오피스 검색(무한스크롤), 채팅 등에서 사용자의 검색 필터링에 따라 수시로 데이터 결과 값이 변경되어야 합니다. 많은 데이터가 수시로 변경되는 부분에 있어 속도와 성능 관련하여 문제가 있을 수 있다고 판단하여 성능적인 측면에서 캐싱 처리를 고민했습니다. |
| **해결 방안** | 1. Axios만을 이용한 데이터 통신 <br> 2. Axios와 React Query를 함께 사용하여 서버 상태 관리 |
| **의견 조율 및 의정** | ⇒ `성능을 위해 캐싱 기능에 대한 고려가 필요` <br> <br> 1. Axios는 HTTP 요청을 처리, 캐싱과 상태 관리는 지원하지 않음 <br> 2. 상태 관리와 캐싱이 필요할 경우 React-query와 함께 사용하는 것이 더 적합 <br> 3. 리액트 쿼리의 장점(최신 데이터 자동 동기화 기능, 캐싱, 서버 데이터 처리 로직 분리로 가독성 및 유지보수성 증가 등) <br> <br> react-query를 사용하게 되면 캐싱 데이터를 사용하여 중복되는 데이터 요청을 줄이고, 필요할 때에 캐싱된 데이터와 새로 업데이트 된 데이터를 새로 가져올 수도 있습니다. 이렇게 캐싱 처리된 데이터를 사용하게 되면 사용자가 빠르게 데이터를 확인할 수 있기 때문에 사용자 경험성이 향상될 것으로 판단하여 react-query를 도입하였습니다. |
| **결과** | eact-query의 캐싱 기능으로 검색 속도와 불필요한 데이터 요청이 최적화되어 사용자 경험성이 증가하였습니다. 유저 테스트 결과 초기 로딩 및 검색 속도 문항에서 76.3%의 유저들이 ‘빠르다’라고 답하였습니다. |

<br>

</details>

<details>
  <summary> <b>Recoil</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 전역 상태 관리 라이브러리 중 React에 최적화 되어있고, 안정적인 recoil을 recoil을 사용하여 간편하게 로그인 전역 상태, 모달 상태, 검색 쿼리, 토글 등의 클라이언트 상태를 관리하기 위해 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 저희 OHPick서비스의 검색, 모달, 로그인 상태관리 등의 기능에서 클라이언트의 전역 상태 관리의 필요성을 느꼈습니다. 주요 데이터인 오피스 데이터들은 주로 서버 상태 관리로 이루어지기 때문에 그밖에 간단하고 가벼운 기능들을 편리하게 관리할 수 있는 전역 상태 관리 라이브러리가 필요했습니다. 기존에는 Redux 또는 useContext를 사용하였었으나 단지 전역 상태를 관리하는 데에 너무 불필요하게 복잡한 과정을 거쳐야 하고, Boiler Plate 초기 세팅이 요구되는 등의 문제가 있어 더 편리하고 가벼운 라이브러리가 필요했습니다. |
| **해결 방안** | 1. Redux로 관리 <br> 2. useContext로 전역 관리 <br> 3. Recoil로 관리 |
| **의견 조율 및 의정** | 전역 상태 라이브러리를 사용하기 전, React 자체에서 제공하는 Hook의 useContext를 이용해 전역 상태를 관리해 보았습니다. 하지만 useContext를 사용해 보니 Redux보다 크게 간단 하다거나 편리하다는 느낌을 받지 못했습니다. 추후 recoil을 도입해 리팩토링 해보니 recoil이 리액트에 최적화 되어 안정성도 높고, 코드도 줄어 가장 관리가 쉽고 편리하게 전역 상태를 관리할 수 있다고 생각되어 recoil을 사용하는 것으로 결정하였습니다. |

<br>
  
</details>

<details>
  <summary> <b>ESLint(airBnB) + Prettier</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | ESLint(airBnB)와 Prettier로 컨벤션을 강제(에러), 강제한 컨벤션 규칙에 맞게 Prettier에서 자동으로 교정해 주도록 설정하여 컨벤션에 맞춰 코드를 작성할 수 있도록 하기 위해 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 팀원과의 협업 과정 중에서 변수명, 함수명, api명 등 컨벤션적으로 맞지 않는 부분들이 발생하여 코드의 통일성, 가독성이 좋지 않고 혼란스러운 상황이 많이 발생 하였습니다. |
| **해결 방안** | 1. ESLint 기본설정과 Prettier를 사용해 컨벤션을 유지한다. <br> 2. ESLint airBnB와 Prettier를 사용해 좀 더 강력한 컨벤션을 강제하여 규칙을 준수하도록 한다. |
| **의견 조율 및 의정** | 처음에는 기본적인 ESLint 설정으로만 진행하고자 하였으나, 그렇게 되면 강제성이 미약하여 코드의 통일성을 유지하고자 하는 목적성이 떨어진다고 판단하였고, 좀 더 강력한 airBnB스타일을 적용하게 되면 웹 접근성이나 검색 엔진 유입률까지 향상시킬 수 있다고 판단되어 ESLint(airBnB) + Prettier를 사용하기로 결정 하였습니다. |
| **결과** | ESLint(airBnB) + Prettier의 강제성 덕분에 적절한 태그 사용 및 라벨링으로 검색엔진 및 웹 접근성 점수가 향상되어 Light-house 측정 결과 웹 접근성, SEO에서 100점에 도달할 수 있었습니다. |

<br>
  
</details>

<details>
  <summary> <b>SCSS(Sassy CSS) + Tailwind</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | SCSS 전처리기를 이용해 변수, 함수, 문법 등을 이용해 CSS 코드를 좀 더 편리하게 사용하고 관리하기 위해 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 서비스가 복잡해짐에 따라 CSS파일들을 관리하는데 어려움을 느꼈고, 더 편리한 CSS문법을 사용해 중복되는 코드의 재사용성을 높이면서 유지 보수가 용이하게 하는 전처리기의 필요성을 느끼게 되었습니다. |
| **해결 방안** |	1. 기존 Styled-components 사용<br> 2. SCSS 전처리기 사용<br> 3. Tailwind 사용<br> 4. SCSS + Tailwind 부분적 사용  |
| **의견 조율 및 의정** | Styled-compoenets에서 컴포넌트와 스타일의 영역이 분리되지 않는다는 점 때문에 컴포넌트 내부 로직이 길어지고 가독성이나 유지보수에서 불편함을 느꼈습니다. 다른 전 처리기를 경험해 보고 싶어 고민하던 중, Tailwind의 사용성이 편리하다고 생각되어 Tailwind만 사용하고자 하였습니다. 하지만 Tailwind의 고유 키 값이 CSS키값과 다르기 때문에 CSS를 능숙하게 사용려면 순수 CSS를 우선적으로 사용 하는 것이 실력 향상에 좋다고 판단되어 SCSS(Sassy CSS) 전처리기를 사용하여 순수 CSS의 기존 문법을 그대로 유지하는 선에서 변수, 함수, 중첩 기능 등의 편리한 기능들을 사용하도록 하고, 부분적으로 굳이 SCSS파일을 사용하지 않아도 되는 간단한 컴포넌트일 경우에는(로딩 스피너 등, 폴더 생성 및 SCSS파일 같이 관리 등의 번거로움 발생), Tailwind를 사용하여 간편하게 스타일을 적용 하였습니다. |

<br>
  
</details>

<br>

### 👥 BACK-END

<details>
  <summary> <b>WebSocket Stomp</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 사용자들이 여러 게시물의 작성자들과 다른 내용의 채팅을 원활하게 할 수 있도록 하기 위해서 채팅 기능을 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 저희 서비스의 주요 기능 중 하나인 게시글의 작성자와 소통을 하게 해주는 실시간 채팅 기능을 도입하기로 결정하였습니다. 이때 사용자는 여러 게시물의 작성자와 각기 다른 내용의 채팅이 실시간으로 가능해야 하기에, 여러 채팅 방에 접속이 가능해야 했는데, 이 기능을 어떻게 구현 할지 고민이 되었습니다. |
| **해결 방안** | 1. http 방식을 사용해서 채팅 구현 <br> 2. WebSocket 방식을 사용하여 구현 |
| **의견 조율 및 의정** | => `서버 부담 가능성 및 기능 고려 필요` <br> <br> -> http 방식은 실시간 채팅을 위한 지속적인 서버와의 요청 및 응답이 필요 (서버 과부화 예상) <br> -> 반면 Websocket은 http 요청과 응답 한번으로 handshake 후, tcp 연결 유지하여 새로운 요청 없이도 데이터 전송 가능 <br> <br> 처음에는 사용자가 실시간 채팅 기능을 사용할 때 지속해서 응답을 가져오기 위하여 계속 요청을 보내는 polling, long polling 방식 혹은 서버 측에서 응답(flush)을 지속 해서 보내주는 streaming 방식도 생각해 보았으나, 이런 방식들을 클라이언트가 많아 질 시, 혹은 채팅 메세지가 많아 질 시 서버에 부담이 가고 예상하지 못한 오류가 많았을 것이라고 판단이 되었습니다. 이로 인해, 실시간 채팅을 하여도 서버에 부담이 많이 안 가고 tcp연결을 통하여 요청과 응답의 오베허드를 줄여 데이터 전송의 효율성을 높여주는 Websocket을 사용하기로 결정하였습니다. 또한. 저희 서비스에 중요 기능 중 하나인 한 사용자가 여러 채팅 방에 접속이 되는 것을 가능케 해주는 WebSocket Stomp를 적용하기로 결정하였습니다. 이로 인해 서버 과부화 없이 여러 실시간 채팅 방 생성이 가능하였습니다. |

<br>

</details>

<details>
  <summary> <b>QueryDSL</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 서비스의 주요 기능에 사용 될 복잡한 쿼리를 해결할 방법이 필요하여 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 저희 서비스의 키워드 검색, 필터링 검색, 및 채팅 방 리스트 불러오기 같은 주요 기능들을 구현하기 위해서는 복잡하지만, 알맞은 쿼리를 데이터베이스에 보내어서 필요한 데이터를 가져와야 했습니다. 이때 필요한 쿼리를 어떻게 작성 해야 할지 고민 되었습니다. |
| **해결 방안** | 1. 기본 JPA <br> 2. JPQL <br> 3. Query DSL |
| **의견 조율 및 의정** | 처음에는 기본 JPA를 사용하여 여러 쿼리를 보내어서 작성하려 했으나 여러 쿼리 작성 방법에 대해 찾아보다가 여러 쿼리를 보내는 것이 하나의 쿼리를 보내는 것 보다 더 많은 시간이 걸린다고 하여서, 더 작은 수의 쿼리를 보내는 방법을 선택하기로 하였습니다. 이로 인해 JPQL도 고려해보았으나, 이는 compile 단계에서 에러 체크가 불가하기 때문에 java 코드로 쿼리를 작성하고, compile 단계에서 에러 체크가 가능한 QueryDSL을 사용하기로 결정하였습니다. |

<br>
  
</details>

<details>
  <summary> <b>CI/CD</b> </summary>
    
<br>

| <br> **도입 이유** <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 프로젝트의 원활한 진행을 위해 배포가 자동으로 이루어져야 해서 도입하였습니다. |
| :-: | :-- |
| **문제 상황** | 백엔드 측 코드에 변경이 생길 때 마다 프로젝트 빌드 및 서버에 파일을 옮겨서 배포를 직접 해줘야 하는 상황이 반복적으로 발생함으로써 클라이언트에게 빠르게 코드를 반영해주기 어려웠습니다. |
| **해결 방안** | 1. Jenkins <br> 2. Dockers <br> 3. Git Action |
| **의견 조율 및 의정** | 처음에는 Jenkins, Docker도 생각해보았으나 별도의 서버 설치가 필요하기에 보다 적용하기 수월하고 쉽게 다룰 수 있는 Github Actions를 사용하기로 결정하였습니다. 또한, 다른 AWS 서비스와 관리 환경이 같은면서 통합적 지원이 잘 되고 안정적인 배포를 보장하는 AWS CodeDeploy를 사용하기로 결정하였습니다. |

<br>
  
</details>

<br>

<br>
  
## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 트러블 슈팅 🔥<br>

### 👥 FRONT-END

<details>
  <summary> <b>무한 스크롤 - useInfiniteQuery 도입</b> </summary>
    
<br>

`문제상황`

유저 피드백에서 ‘전체 조회 시 20개만 조회 할 수 있다. 더 많은 공간을 보고 싶다’는 피드백이 있어 무한 스크롤을 도입하게 되었습니다. 무한 스크롤을 도입하게 되면 아무래도 페이지 로딩 속도가 느려질 수 있기 때문에 성능 측면에서 캐싱 처리가 가능한 useQuery와 따로 throttle을 구현하지 않고도 이벤트 횟수를 줄일 수 있는 IntersectionObserver API로 무한 스크롤 기능을 구현 하였습니다. 하지만 한 번 스크롤 시 Observer 버튼이 계속해서 뷰 포트 상에 노출되어 계속해서 [ 옵저버 중복 실행 → 페이지 상태가 계속 증가 → 데이터 통신 ]이 계속되어 페이지가 늘어나는 현상이 발생했습니다.

`해결 방안`

1안 : Observer의 prevent상태를 관리하여 옵저버가 실행되어 true인 상태일 동안은 [ 옵저버 실행 → 페이지 증가 → 데이터 통신 ] 과정이 일어나지 않도록 직접 상태를 컨트롤 하여 중복 실행을 방지

2안 : useInfiniteQuery를 도입하여 페이지 상태 관리를 직접 하지 않고 fetchNextPage 함수를 이용하며, 옵저버는 isFetching(실행중)일 경우 발생하지 않도록 방지

`의견 조율`

두 가지 방안으로 모두 개발하여 성능적으로 어떤 방안이 더 좋은지 테스트해 보았습니다.

1안일 경우 3가지의 문제가 있었습니다.

1. 추가 구현이 필요 하다 : Intersection Observer API는 교차 여부를 감지하는 기능만 제공하므로 데이터 페칭 및 상태 관리와 관련된 로직은 직접 구현해야 함.
2. 이렇게 무한 스크롤 페이지 및 데이터 상태를 직접 관리하다 보니 검색 상태와 더해져, 상태 관리에 의한 잦은 렌더링으로 성능의 문제 우려됨. 테스트 결과 0~ 6페이지 스크롤까지 평균 20번씩의 렌더링, 검색시에는 최고 40번까지 발생하는 경우도 있었음

![Untitled (21)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/9816651b-d629-43cb-b75d-7db607cfb766)

3. 간혹 연속으로 잦은 검색 시 로딩 스피너만 계속해서 돌아가는 등의 문제가 발생 ![Untitled (22)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/eaa3dc9f-b001-4a4c-b07b-446aa1ed7cf3)

2안일 경우 옵션 함수로 상태를 관리 해 주기 때문에 위의 모든 문제에 대해 자유로웠습니다. 하지만 useInfiniteQuery 자체적으로 초기 데이터 통신이 2번 더 발생하는 문제가 있었습니다.<br> ![Untitled (23)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/c2dc7391-0ce9-4a7c-af32-7a9a4ca7a468)

`의견 결정`

1. 1안은 직접 관리해줘야 할 상태가 최소 3~4개로 더 많기 때문에 0~ 6페이지까지 스크롤 하는데 렌더링이 평균 20회 ~ 검색 시에는 간혹 40회까지 발생했는데, 2안은 평균적으로 13회정도 발생하여 두 배 정도 차이가 났습니다.
2. 또 간혹 발생하는 무한 로딩 스피너 등의 문제가 useInfiniteQuery에서는 발생하지 않았기 때문에 버그 이슈나 사용자 경험성에도 더 나을 것으로 판단하였습니다.
3. useInfiniteQuery를 사용할 경우 개발자가 직접 관리해야 할 로직과 상태 관리가 줄어들어 코드 관리나 유지 보수에도 용이하다고 판단하였습니다.

결과적으로 시간적 여유가 있고 좀 더 세분화하여 기능을 조작해야 할 경우는 직접 페이지 상태 관리와 옵저버 상태를 관리하는 것이 낫다고 판단되었고, 일반적인 경우에는 useInfiniteQuery의 이점이 더 많다고 판단되어 테스트 후 useInfiniteQuery를 사용하여 해결하였습니다.

<br>

</details>

<details>
  <summary> <b>이미지 수정 시 이미지 업로드 방식</b> </summary>
    
<br>

`문제 상황`

저희 서비스에는 멀티 이미지 업로드가 가능한 글쓰기 기능이 개발되어 있었습니다. 글 수정 로직을 신규로 개발함에 있어 시간이 한정적인 상황에서 최대한 효율적인 방법으로 수정 로직을 구현하고자 하였습니다.

`해결 방안`

1안 : 이미지 수정을 하는 경우와 아닌 경우를 나누어 요청하는 방법 (유저가 이미지를 바꾸는 경우에만 파일이 업로드 됨)

2안 : 기존 이미지 URL로 파일 객체를 받아와 유저의 동작과 관계 없이 항상 파일을 업로드 하는 방법 (항상 파일이 업로드 됨)

`의견 조율`

1안을 선택하는 경우,

장점 : 많이 사용하는 방법단점 : 업로드 유무만 나누는 것이 아니라 이미지 순서, 삭제 이미지의 정보 등을 추가로 보내야 해서 로직을 새로 짜야함 (개발시간↑ 로직의 재사용성↓)

2안을 선택하는 경우,

장점 : 항상 파일 객체를 보내기 때문에 로직의 수정이 많이 필요치 않음 (개발시간↓ 로직의 재사용성↑) 단점 : 동일 이미지의 계속적인 업로드로 서버의 자원 낭비 및 이미지 URL을 이용해 S3 버킷에서 직접 이미지 객체 다운로드 시 CORS 에러 발생

`의견 결정`

시간적 한계와 로직의 재사용성 등을 고려하여 최종적으로 2안을 택하였습니다. 그리고 2안이 가지고 있는 문제점을 다음과 같이 해결하였습니다.

1. 서버 자원 낭비 → 수정 이미지 업로드 시 기존 글의 이미지를 모두 삭제 후 업로드 하는 방식으로 해결
2. CORS 에러 → 브라우저가 로컬 캐시를 사용하고 있어서 CORS에러가 나고 있음을 확인하였고, 이 부분을 해결하기 위해 이미지 URL로 get 요청 시 headers에 no-cache 설정을 추가하여 해결

[ CORS 에러 해결 과정 ]

1. S3 CORS 정책 설정 → S3의 경우 요청 헤더에 Origin이 없을 경우 CORS 응답헤더를 전달하지 않음
2. Origin 헤더를 직접 추가하여 요청 → 브라우저가 로컬 캐시를 사용하고 있어 CORS 에러가 지속됨을 확인
3. 이미지 URL로 get 요청 시 headers에 no-cache 설정을 추가

```
const config = {
        headers: {
          'Content-Type': 'multipart/form-data',
          'Cache-Control': 'no-cache',
        },
        responseType: 'blob',
      };
```

<br>

</details>

<details>
  <summary> <b>로그인 상태 유지 - 브라우저에 재 접속 시 Recoil 로그인 전역 상태 초기화 문제</b> </summary>
    
<br>

`문제 상황`

저희 서비스는 사용자의 번거로움을 줄이기 위해 이미 로그인한 사용자라면, 리프레쉬 토큰 만료 전 까지는 브라우저 종료 후 다시 들어와도 로그인 한 상태를 유지해야 합니다. 문제는 Recoil 전역 상태로 토큰을 확인해 로그인 여부를 관리하였는데 브라우저가 실행되면 항상 초기값으로 초기화되기 때문에 Recoil에서 관리하는 로그인 상태의 초기값이 false일 경우 브라우저에서 재 접속 시 초기화 되어 다시 로그인을 해야 하는 상황이 발생했습니다.

`해결 방안`

1. 앱이 처음 mount 되자마자 useEffect를 사용해 토큰의 여부를 확인하여 로그인 상태를 업데이트
2. 로그인 전역 상태의 초기값을 아예 토큰 여부를 확인한 isToken 변수로 설정

`의견 조율`

usEffect를 사용하여 앱이 처음 mount 시 로그인 여부를 업데이트 시키게 되면, 처음 로드됐을 때 외에 새로고침 등 상태값이 초기화 되는 상황 마다 업데이트가 되도록 따로 설정해주어야 합니다. 상태값이 초기값으로 초기화될 때 아예 토큰 여부를 확인한 결과값으로 초기화되게 하면 초기화 되는 모든 상황에서도 항상 토큰여부를 확인하여 결과값으로 로그인 여부를 파악하고 유지할 수 있다고 판단하였습니다.

`의견 결정`

상태의 초기값을 isToken의 토큰 여부를 확인한 결과값으로 초기화되게 하여 전역 상태를 잃는 모든 상황에서도 로그인 여부를 확인하고 유지할 수 있도록 하였습니다.

<br>

</details>

<br>
  
### 👥 BACK-END

<details>
  <summary> <b>채팅 메세지가 올바르지 않게 불러오는 에러</b> </summary>
    
<br>

`문제 상황`

기존 데이터베이스에 저장된 채팅 메시지를 가져올 때, 보내진 순서대로 가져오지 않는 오류가 발생하였습니다. 이를 확인 해보니, 저장된 메세지들을 생성 시간 순으로 가져왔는데, 채팅 메세지 생성 시간을 분 단위로 설정해두어서, 같은 시간 (분 단위) 에 채팅 메세지가 전송이 될 시, 해당 메세지들을 불러 올 때, 무작위로 섞여서 가져오고 있었습니다.

`해결 방안`

1안: 채팅 메세지의 생성 시간을 초 단위로 설정

2안: 채팅 메세지들을 pk값 기준으로 가져오는 방식을 교체

`의견 조율`

1안을 선택 시, 채팅 메세지의 생성 시간이 초 단위로 저장이 되는데, 이때 기존에 채팅 메세지의 시간을 보여주는 형식을 바꿔야 하는 상황이 발생됩니다. 또한, 채팅 생성 시간이 초 단위로 되면, 위와 같은 똑같은 에러가 발생 할 수 있는 경우가 생깁니다.

만약 2안을 선택 할 시에, 기존의 메세지들을 어떠한 방식으로 가져오는 것이 중요하였습니다. 메세지를 보낸 순서 대로 불러 와져야 했기에 채팅 메세지가 데이터 베이스에 저장 될 때, 자동으로 생성되는 pk 값을 이용해 데이터를 가져오면 이 문제를 해결할 수 있었습니다.

`의견 결정`

1안은 기존에 이미 저장된 메세지들의 생성 시간도 변경이 되었어야 했고, 생성 시간을 보여주는 형식도 바꿔야 했으며, 똑같은 문제에 맞닥뜨릴 수 있기 때문에 2안으로 결정하였습니다.

```
List<ChatMessage> messages = chatMessageRepository.findAllByRoomOrderByIdAsc(room)
```

<br>

</details>

<details>
  <summary> <b>예약 종료 상태 관련 이슈</b> </summary>
    
<br>
    
`문제 상황`

저희 서비스에서 사용자가 한 게시글에 예약 일자를 정해서 예약을 하는 경우, 현재 날짜를 기준으로 해당 예약의 예약 종료 일이 지나면 예약 상태가 종료 상태로 변경되어야 했습니다. 하지만 예약 상태를 종료 상태로 바꿔 주는 방법을 구현하지 못 한 상황 이여서 문제가 발생하였습니다. 이로 인해, 예약 종료 일이 지난 예약 현황도 게시글의 예약 현황 리스트에 추가가 되어 반환이 되고 있었습니다.

`해결 방안`

1안: 게시글의 예약 현황 리스트 api 요청이 올 때 마다, 해당 게시글의 각각의 예약 현황의 종료 일들을 현재 날짜와 비교하는 방법을 사용

2안: 지정해둔 시간에 모든 예약 현황의 예약 종료 일을 현재 날짜와 비교할 수 있는 스프링 스케쥴러를 사용

`의견 조율`

1안을 선택 시, 해당 게시글의 예약 현황만 비교하여 비교 대상자가 많이 줄어들지만, 해당 요청에서 의 반환 속도가 늦어 질 수 있습니다. 또한, 다른 게시글의 예약 현황 상태를 안 바꾸어준다는 단점이 있어서 사용자의 예약 현황들을 조회 할 때, 예약 종료일이 지난 예약 현황들도 가져오는 오류가 발생 할 수 있었습니다.

만약 2안을 선택 시, 한번에 모든 예약 현황의 상태를 바꿀 수 있지만, 지정된 시간에 이루어 지기에, 이 시간에 새로운 요청이 들어 올 시, 에러가 발생 할 경우도 있었습니다.

`의견 결정`

예약 기능은 저희 서비스의 주요 기능 중 하나 이기 때문에 다른 api 요청에서도 예약 현황이 사용되어서 만약 예약 종료 일이 지나도 예약 상태가 종료 상태로 안 바뀌어져 있으면 오류가 발생 할 수 있습니다. 이로 인해, 스프링 스켸쥴러를 사용하여 모든 예약 현황의 상태를 변경하는 것으로 정하였습니다. 스프링 스켸쥴러의 작동 시간은 하루가 거의 끝나는 시간으로 지정하여 만약 새로운 예약 요청의 예약 종료일이 당일이 되는 경우를 최대한 줄여서 적용하였습니다.

<br>

</details>

<details>
  <summary> <b>회원 탈퇴 시 연관된 테이블에 의해 삭제가 안되는 문제</b> </summary>
    
<br>
    
`문제 상황`

회원 탈퇴 요청 시 “Cannot delete or update a parent row: a foreign key constraint fails” 이라는 에러 메세지가 나오며 DB에서 삭제가 안되는 문제가 발생하였습니다. 삭제하려는 Member 객체를 확인해보니, Post Entity에서 @ManyToOne형식으로 Member Entity와 연관 관계를 가지고 있었고 Member의 id를 FK로 설정되어 있어서 외래 키 제약 조건에 의한 문제임을 알았습니다.

`해결 방안`

1안: cascade = CascadeType.REMOVE, orphanRemoval = true를 이용해서 데이터베이스에서 삭제하는 방식으로 물리 삭제 (hard delete) 를 사용

2안: 데이터베이스에 데이터를 남겨두고 삭제되었는지 아닌 지를 구분하는 구분자를 추가하여 사용자들에게 보이지 않게 논리 삭제(soft delete)를 사용

`의견 조율`

데이터 베이스의 데이터의 삭제 방식을 hard delete 로 선택할 경우, 데이터를 조회 할 때, where 절을 따로 추가 해줄 필요가 없어서, 조회 속도가 빠르고 데이터베이스의 용량이 매우 커지는 것을 방지 할 수 있습니다. 하지만 이 방식은 데이터의 복구가 불가 하다는 단점이 있습니다. 예를 들어, 사용자가 실수로 데이터를 지웠을 때, 복구 하는 방법이 없습니다. 만약 삭제 방식을 soft delete로 선택 할 경우, hard delete 방식과는 반대로, 데이터의 복구가 가능 하며, update 쿼리가 delete 쿼리 보다 마이크로 초 단위로 더 빠릅니다. 하지만, 구분자가 추가 되어서 조회 속도가 조금 더 느려지고, 데이터베이스의 용량이 계속해서 커지는 단점들이 있습니다.

`의견 결정`

추후 서비스 성능 개선 할 때, 실수로 삭제 했던 게시글이나, 탈퇴를 한 회원이 재 로그인을 시도 할 때 새로운 계정을 만들 필요 없이 기존 계정에 로그인이 가능한 기능을 추가 하려기에, soft delete형식을 선택 하였습니다. 이로 인해, entity 에 is_delete 라는 boolean 필드를 구분자로 추가하고, 디폴트값을 false로 지정하고, 삭제 시 true로 바뀌도록 변경하였습니다. 하지만 현재 서비스 상태로는 복구 기능이 없기 때문에 탈퇴 후 동일한 이메일이나 닉네임을 가지고 가입할 경우가 생길 수 있어서 탈퇴 할 때, 이메일과 닉네임에 지정한 문자열을 붙여서 데이터베이스에 수정되도록 하여 중복으로 기입 되어지는 상황을 방지 하였습니다.

<br>

</details>

<details>
  <summary> <b>카카오 회원 로그인 에러 이슈 </b> </summary>
    
<br>
    
`문제 상황`

카카오 소셜 로그인에서, 카카오 사용자의 이메일을 선택 사항으로 받고 있었습니다. 저희 서비스는 사용자의 이메일을 사용하여 jwt 토큰을 만들어서 클라이언트에게 넘기는데, 이때 사용자가 선택 사항인 이메일 정보 공유에 동의를 안 하고 회원 가입을 할 시에, 이메일 값이 null 값이 되면서 로그인 후 무한 로딩이 되는 오류가 발생하였습니다.

`해결 방안`

1안: 이메일 공유에 미 동의 하였을 시, 이메일 값을 따로 받기.

2안: kakao developer 에서 이메일 정보를 필수 사항으로 바꾸기.

`의견 조율`

1안을 사용 할 시, 양쪽 프론트 엔드와 백 엔드에 추가 작업이 필요하였습니다. 또한, 사용자에게 추가 정보를 받아 와야해서 사용자가 불편함을 느낄 수 있었습니다.

2안을 사용할 경우, kakao developers 에서 앱을 비즈 앱으로 등록해줘야 했습니다.

`의견 결정`

1안을 선택 해서 프론트 엔드, 백 엔드 양쪽에서 추가 작업을 하는 것과 사용자에게 추가 정보를 받는 것은 비효율 적인 방법이라 생각되어 2안을 선택하였습니다. Kakao Developers에서 등록된 앱을 비즈앱으로 전환하여서 이메일 정보를 필수 사항으로 받게 수정하였습니다.

<br>

</details>

<br>

<br>
  
## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 유저 테스트 🧑🏻‍💻<br>

#### 🌱 39명의 유저에게 총 83건의 테스트 피드백을 얻었습니다.

<details>
  <summary> <b>유저테스트 결과</b> </summary>
    
<br>

![Untitled (1)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/24a0ae8c-a437-4d5d-b160-2d3c1718d577) ![Untitled (2)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/d6d72001-31b3-4f59-befc-a2836d622550)

<br>

</details>

<details>
  <summary> <b>유저테스트 피드백</b> </summary>
    
<br>

![Untitled (3)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/37b8c9fe-eb7e-4181-9172-acee3733e401) ![Untitled (4)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/48292a40-cbd7-4e74-8c59-5bd6f75712a7)

<br>

</details>

<details>
  <summary> <b>유저테스트 피드백 반영 결과</b> </summary>
    
<br>

![Untitled (5)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/101d2984-efbf-4d88-a83e-670b605536d1)

<br>

</details>

<details>
  <summary> <b>유저테스트 주요 반영 사항</b> </summary>
    
<br>

![Untitled (6)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/8b538e4f-7dd7-41d9-aeb4-7dba4237a15c)

<br>

</details>

<br>

<br>
  
## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 성능 개선 ♻️<br>

### 👥 FRONT-END

<details>
  <summary> <b>로그인 보안 강화 - 토큰을 클라이언트에서 관리 X</b> </summary>
    
<br>

`개선 전`

유저 피드백에서 `HttpOnly, Secure가 안되어있기 때문에 보안에 취약할 수 있습니다. url에다 javascript: alert(document.cookie); 치면 쿠키가 나옵니다.` 라는 피드백이 있었습니다. 기존에는 access-token과 refresh-token을 모두 cookie에 저장하여 관리하고, 모든 요청의 헤더에 토큰을 모두 보내는 방식을 사용했었습니다. 하지만 이 방식이 보안적으로 다음과 같은 문제들이 있다고 판단하였습니다.

1. 브라우저에서 자바스크립트 문법으로 토큰에 접근 가능(document.cookie)/노출 되는 문제
2. 헤더 탈취 시 access, refresh 모두 탈취 가능성
3. XSS(악의적인 자바스크립트 삽입) 공격에 취약

![Untitled (7)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/590ba964-815f-45fe-9c2d-9f40afe68a67)

`해결 방법`

1. refresh-token은 Https only 쿠키에서 관리
2. access-token은 브라우저 저장소에서 관리하는 자체 만으로도 보안적으로 탈취/노출 위험성이 존재하기 때문에, 브라우저 저장소에 저장하지 않고 axios의 defaults변수에 담아 요청 시 헤더에 담아 전송

`개선 후 결과`

1. refresh-token은 Https only 쿠키에서 관리하여 브라우저에서의 접근을 막고, 클라이언트 쪽의 접근/노출/공격을 방지하였습니다.
2. access-token은 클라이언트 저장소에 저장하지 않기 때문에 토큰이 브라우저 쿠키 또는 로컬 스토리지 등에 노출되는 위험을 줄일 수 있었습니다. 또 클라이언트 저장소에 토큰을 저장하는 경우, 악의적인 사용자가 저장된 토큰을 탈취하여 인증을 우회 할 수 있는 위험이 있을 수 있으므로 저장소에 토큰을 저장하지 않음으로서 위험성을 줄일 수 있었습니다.

![Untitled (24)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/32f3123f-a93e-4792-a04e-e73b0dd8faaa)

3. access-token은 클라이언트 저장소에 저장하지 않기 때문에 토큰이 브라우저 쿠키 또는 로컬 스토리지 등에 노출되는 위험을 줄일 수 있었습니다. 또 클라이언트 저장소에 토큰을 저장하는 경우, 악의적인 사용자가 저장된 토큰을 탈취하여 인증을 우회 할 수 있는 위험이 있을 수 있으므로 저장소에 토큰을 저장하지 않음으로서 위험성을 줄일 수 있었습니다.

<br>

</details>

<details>
  <summary> <b>Lazy Loading 지연 로딩</b> </summary>
    
<br>

`개선 전`

많은 오피스 사진과 데이터들을 사용자에게 제공하다 보니, 이미지 리소스가 많을 수록 페이지가 로딩 되는 속도가 증가하고, 깜빡이는 문제를 해결해야 했습니다. 원인을 분석해 보니 페이지를 읽어올 당시에 화면 상에 나타나지 않는 리소스들까지 너무 많은 리소스를 로드하고 있다는 것을 깨달았습니다. 따라서 페이지 당 게시물 개수를 20개에서 → 10개로 줄였지만, 그럼에도 불구하고 화면상에 보이지 않는 리소스까지 로드하기 때문에 초기 페이지 로딩 시간이 증가하고 웹 성능적으로도 좋지 않은 점수가 나왔습니다. → 성능 점수 77점

![lazy 전.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c83b0b73-84df-4c31-99f3-6b75a3336998/lazy_%EC%A0%84.gif)

![lazy전 성능.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/20db9824-a929-4331-9911-f0a56c6511fc/lazy%EC%A0%84_%EC%84%B1%EB%8A%A5.gif)

`해결 방법`

lazy-load(지연 로딩)을 사용하여 현재 화면 상 사용자에게 보여지지 않는 이미지나 비디오 등 리소스들의 로딩을 지연시켜 초기 페이지 로딩 시간을 감소시키고, 리소스를 최적화하였습니다.

`개선 후 결과`

**페이지 로딩 시간 감소** : 리소스 로딩을 지연시킴으로써 초기 페이지 로드 시간을 줄였습니다. - FCP(초기 로딩 속도) 0.8초 → 0.5초로 개선 - LCP(큰 콘텐츠 로딩 속도) 1.57초 → 0.87초로 개선 - CLS(레이아웃 변동) 0.0206 → 0.00895로 개선 - 즉 페이지의 초기 로딩 속도, 큰 콘텐츠의 로딩 시간, 레이아웃 변동과 관련된 성능 지표 모두에서 개선 된 것을 확인할 수 있었습니다. **리소스 사용 최적화** : 리소스를 지연 로드하여 사용자 리소스(사용자의 배터리, 시간, 시스템 리소스)와 시스템 리소스 사용을 최적화 하였습니다. light house 성능 점수 77점 → 87점으로 향상된 것을 확인하였습니다.

![lazy후.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/71e0e45f-7646-45c6-a0ef-edb45674c2b9/lazy%ED%9B%84.gif) ![Untitled (9)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/48c75cb3-2cbe-4cef-b5ec-51acaa881ef5) ![Untitled (10)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/c15e2d63-7cbc-4e15-b911-92c054536628)

<br>

</details>

<details>
  <summary> <b>light-house 웹 접근성, SEO 최적화 100점</b> </summary>
    
<br>
 `개선 전`
 
웹 접근성에 좋지 않은 태그 요소가 포함되어있거나, 중복되는 id값이 존재, 검색 엔진이 읽을 수 있는 robots.text의 누락 등 웹 접근성과 검색 엔진 점수가 각각 92, 91 점으로 조금 미흡한 부분이 있었습니다.
 
 ![lazy전 성능.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31c44eab-25b5-453d-86da-4288eb5d4e69/lazy%EC%A0%84_%EC%84%B1%EB%8A%A5.gif)

`해결 방법`

light-house에서 제시하는 경고를 확인하고, 웹 접근성에서 추구하는 방향으로 태그 요소를 개선하였습니다. 불필요한 태그나 중복 id등은 제거하고, 누락된 robots.txt 파일을 추가하는 등 웹 접근성과 검색 엔진 기능을 향상 시켰습니다.

`개선 후 결과`

웹 접근성과 SEO 점수가 100점으로 향상되었습니다.

![웹 접근성, 검색엔진 최적화](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/45ba58a8-300d-4056-8ee4-0d2b502d728b)

<br>

</details>

<br>

### 👥 BACK-END

<details>
  <summary> <b>액세스 토큰, 리프레시 토큰 전송 방식 수정</b> </summary>
    
<br>

`개선 전`

JWT 액세스 토큰, 리프레시 토큰을 클라이언트에 보낼 때, response.addHeader 방식으로 보내고 있었는데, 이렇게 하니, 개발자 도구에서 document.cookie 를 하면, 토큰 값이 노출 되었습니다. 이로 인해, 보안 측에 문제가 있었습니다.

![Untitled (11)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/581b8ebc-eac3-4a89-b9d2-79b14d4a9989) ![Untitled (12)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/8bb5bc21-b56e-4d20-8bbc-d5a694bcb5e9)

`해결 방법`

쿠키에 httpOnly 와 secure 가 적용되면 http 요청일 때만 쿠키 값이 접근이 되어서 document.cookie로 접근이 불가 합니다. 이를 통해 개선 전 문제가 해결되지만 액세스 토큰과 리프레시 토큰 전부를 쿠키로 전송하는 것은 CSRF 공격에 취약하기 때문에, 액세스 토큰을 재 발급 해주는 용도로만 사용되는 리프레시 토큰만 쿠키로 수정하였습니다.

![Untitled (13)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/fe4ea58b-559d-451f-8b89-55d7502e797a) ![Untitled (14)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/6989bd6f-db13-4e00-9438-c249150eb042)

그리고, 인증된 사용자인지 확인 해주는 액세스 토큰은 CSRF나 XSS 같은 보안 공격에 대응하기 위하여 클라이언트에서 private 변수 값으로 저장하는 방식을 선택하였습니다. 이를 가능케 할 수 있도록 response의 body 를 통해 전송하는 방식으로 수정하였습니다. 또한 액세스 토큰이 만료 될 때 마다, 쿠키에 담겨진 리프레시 토큰을 사용하여 재발급 해주는 api도 구성하였습니다.

![Untitled (15)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/cf5cb993-fa0a-4547-baa9-bd643ada2f45) ![Untitled (16)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/1bec6475-785d-42e0-b047-f6dc8d5863c3)

`개선 후 결과`

변경 사항 적용 후, 사용자가 로그인 요청을 하였을 시, 액세스 토큰이 response의 body 값으로 들어오는 것을 확인 할 수 있었습니다. 또한, 개발자 도구로 document.cookie 를 하였더니, 쿠키로 수정된 리프레시 토큰 및 private 변수로 저장된 액세스 토큰 노출이 안되었습니다. 이로써 보안을 강화하였습니다.

![Untitled (17)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/3c43184b-89e1-460a-9f3d-fd4baf2a9db7) ![Untitled (18)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/85ae1e2e-0841-4f16-971c-861ce14e3a2a)

<br>

</details>

<details>
  <summary> <b>이메일 인증 코드, 리프레시 토큰 저장 장소 변경</b> </summary>
    
<br>

`개선 전`

이메일 인증 코드와 리프레쉬 토큰은 RDS에 MySQL DB를 연결하여 저장하고 관리하였습니다. 하지만 이로 인해, 간단한 조회 및 인증 과정에 사용하기 위해 매번 SQL 쿼리를 통해 DB에 접근해야하는 불편함이 있었습니다.

`해결 방법`

이메일 인증 코드와 Refresh Token은 비교적 일시적인 데이터로 데이터의 지속성 보다는 주로 빠른 접근과 만료 처리를 용이하게 하는 효율성이 중요하였습니다. 그래서 메모리에 데이터를 저장하여 빠른 접근, key- value 쌍의 구조로 단순한 데이터 구조를 편하게 관리할 수 있고, 만료 시간을 설정할 수 있는 redis로 저장 장소를 변경하였습니다.

`개선 후 결과`

예를 들어, 이메일 인증 요청시 "SETEX" "[email_verif_codekjs3@naver.com](mailto:email_verif_codekjs3@naver.com)" "180" "2g88K9jn"라고 서버에 저장이 되었습니다. 만료 시간은 3분으로 설정하였습니다.

사용자가 인증 코드 입력하여 인증 완료 시 인증된 이메일로 "SETEX" "[email_verifiedkjs3@naver.com](mailto:email_verifiedkjs3@naver.com)" "180" "true"로 설정하고, 데이터가 삭제되도록 설정하였습니다.

![Untitled (19)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/ae040509-db1b-4c50-b063-9bcbd84177ca)

또한 사용자가 로그인 시 Refresh token 저장하도록 하였습니다.

![Untitled (20)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/527eaf00-d8bb-46d5-9ca2-0e55a730886f)

<br>

</details>

<details>
  <summary> <b>채팅 방 리스트 불러오기 쿼리 개수 및 시간 줄이기</b> </summary>
    
<br>

`개선 전`

채팅 방 리스트를 가져오는 요청을 보냈을 때, 여러 데이터베이스에 필요한 데이터들을 가져와야 하기 때문에 실행 될 때 걸리는 시간이 생각보다 오래 걸렸습니다.

![채팅 방 리스트 불러오기 전](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/352e7ac0-2dc5-4743-b0a2-d819cc1d280a)

`해결 방법`

채팅 방 리스트에서 각 채팅 방에 게시글(post)의 제목과 사진을 가져와야 했는데, 이때 post 객체에 1대1 양방향 연관 관계로 연결되어 있던 다른 객체들에게 쿼리문을 각자 보내고 있었어서 post 객체를 조회 할 때 연관된 다른 객체들을 `join` 해서 조회 하도록 변경하였습니다. >

![채팅 방 리스트 불러오기 후 - 조치 1 (1)](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/c64b4c12-bdcc-4f07-a07c-1992a2cec439)

이 후, 쿼리의 개수와 시간은 줄었지만 아직 요청 시간이 오래 걸렸습니다. ![채팅 방 리스트 불러오기 후 - 결과 1](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/71835427-fba4-4da9-a245-6614785c5fbe)

채팅 방 리스트를 불러오는 쿼리를 Query Dsl 로 작성하였는데, 이 쿼리문을 수정 하였습니다.

![채팅 방 리스트 불러오기 후 - 조치 2-1](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/37abb0b4-0ef6-47d2-9637-de33e4bed7be) ![채팅 방 리스트 불러오기 후 - 조치 2-2](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/091f3bf3-5b02-4d8b-9426-4c4dbdfec5a8)

`개선 후 결과` 채팅 방 리스트 조회 요청을 보낼 시, 실행되는 시간이 현저히 줄어들었습니다. ![채팅 방 리스트 불러오기 후 - 결과 2](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/8db0cac2-fa1f-4a53-a759-f7b59c16d734)

<br>

</details>

<br>

<br>
  
## ![로고](https://github.com/ShareOffice-11/OHPickOfficial/assets/83201893/064c9d75-fbd9-40b2-867c-a31359cfc231) 팀원 소개 & 팀원 역할 👨‍👩‍👧‍👦 <br>

<div align=center width=100%>
<img src="https://github.com/OHPick/.github/assets/83201893/264ab20b-4b85-4314-ae9e-053db545dcbb" width=100% />
</div>

| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>**역할** | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br> **이름** | **담당** | **Github** | **E-mail** |
| :-: | :-: | --- | :-: | :-: |
| FE ⭐<br> `Leader` | 이준영 | 로그인(일반) <br> 소셜 로그인(카카오) <br> 인트로페이지 <br> 메인페이지 <br> 글작성 페이지 <br> 검색 기능 <br> 필터(정렬, 지역) <br> 지도 API <br> 위치 검색, 페이지네이션 <br> 무한스크롤 <br> 채팅, 멀티 이미지 | https://github.com/junvely | junvely97@gmail.com |
| FE | 왕정민 | 상세 페이지 <br> 예약 및 예약 확인 페이지 <br> 글 작성 페이지(멀티이미지 업로드) <br> 글 수정 페이지 <br> 마이페이지 <br> 채팅 목록 및 채팅 룸 <br> 이메일 인증 <br> 회원가입 | https://github.com/v-va | poruch0915@gmail.com |
| BE ⭐<br> `Vice Leader` | 박우현 | 서버 배포(AWS, EC2, CI/CD, Git Action) <br> 채팅 (STOMP 웹소켓) <br> 예약 시스템 <br> 예외처리 <br> jwt 리프레쉬 토큰 쿠키 <br> route 53 https <br> 탄력IP <br> 이메일 인증 <br> Statement Inspector를 사용한 요청 쿼리 개수 및 총 요청 시간 파악 <br> 스프링 스케쥴러 | https://github.com/JoshWPark | parkjoshua98@gmail.com |
| BE | 마동찬 | 게시글 CRUD <br> 좋아요 <br> S3이미지 <br> 카카오로그인 <br> 채팅(STOMP 웹소켓) <br> 마이페이지내 목록조회 | https://github.com/mdc2684 | mdc53@naver.com |
| BE | 강준수 | 회원가입, 로그인, 로그아웃, 회원탈퇴 <br> Swagger <br> Redis <br> 메인페이지 필터링, 페이지네이션 | https://github.com/Kangjunesu | kulbit92@naver.com |
| Designer | 김민선 | 디자인 담당 |  |  |
